<!DOCTYPE html>
<html lang="hu">

<head>
    <meta charset=utf-8>
    <title>NAGY beadandó</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { width: 100%; height: 100% }

        body { margin: 0; overflow: hidden; }
        canvas { width: 100%; height: 100% }
        #info {
            position: absolute;
            top: 30px;
            left: 10px;
            width: 200px;
            text-align: left;
            z-index: 100;
            display:block;
            color: black;
            font-size: 7px;
            opacity: 0.7;
        }
        #info a { color: #f00; font-weight: bold; text-decoration: underline; cursor: pointer }
    </style>
</head>

<body>

<div id="info">
    <p id="infopanel"></p>
</div>


<script async src="./dist/es-module-shims.js"></script>
<script type="importmap">
{
    "imports": {
        "three": "./js-r178/build/three.module.js",
        "trackballcontrols": "./js-r178/examples/jsm/controls/TrackballControls.js",
        "OBJLoader": "./js-r178/examples/jsm/loaders/OBJLoader.js",
        "MTLLoader": "./js-r178/examples/jsm/loaders/MTLLoader.js"
    }
}
</script>

<script type="module">
    import * as THREE from 'three';
    import { OBJLoader } from 'OBJLoader';
    import { MTLLoader } from 'MTLLoader';
    import { TrackballControls } from 'trackballcontrols';

    let loadedModels = {};

    function loader_obj_mtl(OBJFile, MTLFile, name, manager) {
        manager.itemStart(OBJFile);

        new MTLLoader()
            .load(MTLFile, function (materials) {
                materials.preload();
                new OBJLoader()
                    .setMaterials(materials)
                    .load(OBJFile, function (object) {

                        object.traverse(function (child) {
                            if (child instanceof THREE.Mesh) {
                                child.scale.set(3, 3, 3);
                                child.castShadow = true;
                                child.receiveShadow = true;
                                child.material = new THREE.MeshPhongMaterial( {
                                    color: child.material.color,
                                    shininess: 10,
                                    specular: 0x000000,
                                    wireframe: wire_frame} );
                            }
                        });

                        loadedModels[name] = object;
                        manager.itemEnd(OBJFile);
                    });
            });
    }

    // Globális változók
    let WIDTH, HEIGHT, aspectRatio;
    let renderer;
    let scene, camera;
    let controls;
    let wire_frame = false;  // wireframe vagy kitöltött módban való megjelenítés
    let shadow = true;  // hogy ne robbanjon szét a gép

    let plane_size = 800;
    let sky_rad = plane_size / 2;
    let infoPanel;

    let starHolder;
    let fireFlyHolder;
    let lombHolder;

    let smurfArray = [];
    let smurfHolder;
    let smurfFlipping = false;
    let smurfToFlip;

    // vezerles

    let ff_time = 0;
    let smurf_time = 0;
    let windowLightsOn = true;
    let windowLights = [];

    let fireFlyLightsOn = true;
    let fireFlyLights = [];

    let day = true;
    let ambientLight;
    let moonDirLight;
    let sunDirLight;
    function setInfoPanelText( msg ) {
        infoPanel.innerHTML = msg;
    }

    function appendInfoPanelText( msg ) {
        let str = infoPanel.innerHTML;
        str = str + '<br/>' + msg;
        infoPanel.innerHTML = str;
    }

    let tree_names = ['tree', 'tree2', 'tree3'];
    let rock_names = ['rock1', 'rock2', 'rock3', 'rock4', 'rock5'];
    let trunk_names = ['trunk', 'trunk2']

    function populateScene() {
        for (let i = 0; i < 200; i++){
            let x = plane_size*Math.random()-sky_rad;
            let z = plane_size*Math.random()-sky_rad;

            if(!clipsIntoHouse(x,z, 0, 0) && !clipsIntoHouse(x,z, 10, 70)) {
                makeCustomTree(x, 0, z, scene, random_choice(tree_names));
            }
        }
        for (let i = 0; i < 200; i++){
            let x = plane_size*Math.random()-sky_rad;
            let z = plane_size*Math.random()-sky_rad;

            if(!clipsIntoHouse(x,z, 0, 0) && !clipsIntoHouse(x,z, 10, 70)) {
                makeCustomRock(x, 0, z, scene, random_choice(rock_names));
            }
        }
        for (let i = 0; i < 50; i++){
            let x = plane_size*Math.random()-sky_rad;
            let z = plane_size*Math.random()-sky_rad;

            if(!clipsIntoHouse(x,z, 0, 0) && !clipsIntoHouse(x,z, 10, 70)) {
                makeCustomTrunk(x, 0, z, scene, random_choice(trunk_names));
            }
        }
    }

    init();
    function init() {

        // Böngésző ablakméret lekérése és méretarány számítása
        HEIGHT = window.innerHeight;
        WIDTH = window.innerWidth;
        aspectRatio = WIDTH / HEIGHT;

        // Renderer létrehozása és DOM-hoz adása
        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setSize( WIDTH, HEIGHT );
        renderer.setClearColor( 0x000000 );
        renderer.shadowMap.enabled = shadow;
        document.body.appendChild( renderer.domElement );

        // Színtér létrehozása
        scene = new THREE.Scene();

        // Kamera létrehozása és vetítési paramétereinek beállítása
        camera = new THREE.PerspectiveCamera( 80, aspectRatio, 0.1, 1000 );
        camera.position.set( -sky_rad/3, 50, -sky_rad/3);
        camera.lookAt( scene.position.x, scene.position.y + 50, scene.position.z );

        ////////////////// 4. bead: LoadingManager //////////////////
        infoPanel = document.getElementById( 'infopanel' );

        setInfoPanelText( 'Erőforrások betöltése!' );

        let manager = new THREE.LoadingManager();
        manager.onProgress = function ( item, loaded, total ) {
            console.log( 'Manager onProgress:', item, 'kész; ', loaded, ' a ', total, '-bol betöltve.' );
            let progressString = item + ' kész;<br/>' + loaded + ' a ' + total + '-bol betöltve';
            appendInfoPanelText( progressString );
        };
        manager.onLoad = function () {
            console.log( 'onLoad meghívva, renderelés megkezdése.' );
            appendInfoPanelText( 'onLoad meghívva, renderelés megkezdése' );
            populateScene();
            animate();
        };

        for(let i = 0; tree_names.length > i; ++i){
            loader_obj_mtl('assets/my_models/'+tree_names[i]+'.obj', 'assets/my_models/'+tree_names[i]+'.mtl', tree_names[i], manager);
        }

        for(let i = 0; rock_names.length > i; ++i){
            loader_obj_mtl('assets/my_models/'+rock_names[i]+'.obj', 'assets/my_models/'+rock_names[i]+'.mtl', rock_names[i], manager);
        }

        for(let i = 0; trunk_names.length > i; ++i){
            loader_obj_mtl('assets/my_models/'+trunk_names[i]+'.obj', 'assets/my_models/'+trunk_names[i]+'.mtl', trunk_names[i], manager);
        }

        let textureLoader = new THREE.TextureLoader( manager );

        ////////////////// event listener //////////////////
        window.addEventListener('keydown', keyDown);

        function keyDown(event){
            switch (event.keyCode){
                case '1'.charCodeAt(0):
                    windowLightsOn = !windowLightsOn;
                    toggleWindowLights();
                    break;

                case '2'.charCodeAt(0):
                    fireFlyLightsOn = !fireFlyLightsOn;
                    toggleFireFlyLights();
                    break;

                case 'L'.charCodeAt(0):
                    day = !day;
                    toggleDayNightLight();
                    break;
            }
        }

        ////////////////// Objektumok létrehozása //////////////////

        starHolder = new THREE.Object3D();
        fireFlyHolder = new THREE.Object3D();
        smurfHolder = new THREE.Object3D();
        lombHolder = new THREE.Object3D();

        // Talaj
        let plane_rot = THREE.MathUtils.degToRad(90);
        let planeGeometry = new THREE.PlaneGeometry( plane_size, plane_size, 2, 3 );
        let planeMaterial = new THREE.MeshLambertMaterial( { color: 0x194d00, wireframe: wire_frame, side: THREE.doubleSided } );
        let planeMesh = new THREE.Mesh( planeGeometry, planeMaterial );

        planeMesh.rotation.set(-plane_rot, 0, 0);
        planeMesh.scale.set(1,1,1);  // beadandó követelmény
        planeMesh.receiveShadow = true;
        planeMesh.castShadow = true;
        scene.add( planeMesh );

        // Ég
        let skyGeometry = new THREE.SphereGeometry(1, 60, 40);
        let skyMaterial = new THREE.MeshStandardMaterial({color: 0x050399, side: THREE.BackSide, wireframe: wire_frame});
        let skyMesh = new THREE.Mesh( skyGeometry, skyMaterial );
        skyMesh.scale.set(sky_rad, sky_rad, sky_rad);
        skyMesh.position.set(0, 2, 0)  // beadandó követelmény

        scene.add(skyMesh)

        let foilageTextures = [];

        for(let i = 1; i <= 3; i++){
            foilageTextures.push(textureLoader.load('texture/foilage'+i+'.jpg'))
        }

        //makeMagicTree(100, 0, 0, scene);

        let faceTextures = [];

        for (let i = 1; i <= 4; i++){
            faceTextures.push(textureLoader.load('texture/face'+i+'.jpg'))
        }
        // Törpeültetés
        for (let i = 0; i < 50; i++){
            let x = sky_rad*Math.random()-plane_size/4;
            let z = sky_rad*Math.random()-plane_size/4;

            if(!clipsIntoHouse(x,z, 0, 0) && !clipsIntoHouse(x,z, 10, 70))  // csúnya house clip check
                makeSmurf(x, 0, z, scene, random_choice(faceTextures));
        }

        //
        let doorTexture = textureLoader.load('texture/door.jpg');
        let windowTexture = textureLoader.load('texture/window.jpg');
        let roofTexture = textureLoader.load('texture/roof.jpg');
        makeHouse(0,5,0,scene,doorTexture,windowTexture,roofTexture);
        makeHouse(10,5,70,scene,doorTexture,windowTexture,roofTexture);

        // Hold
        let moon_x = sky_rad/2;
        let moon_z = sky_rad/2;
        let moon_y = skyY(moon_x, moon_z, sky_rad);

        let moonTexture = textureLoader.load('texture/moonmap1k.jpg');

        let moonGeometry = new THREE.SphereGeometry(25,32,32);
        let moonMaterial = new THREE.MeshBasicMaterial({color: 0xffffffff});
        moonMaterial.map = moonTexture;
        let moon = new THREE.Mesh(moonGeometry, moonMaterial);
        moon.position.set(moon_x, moon_y, moon_z)

        starHolder.add(moon);

        // Nap

        let sunGeometry = new THREE.SphereGeometry(25,32,32);
        let sunMaterial = new THREE.MeshBasicMaterial({color: 0xf2f20f});
        let sun = new THREE.Mesh(sunGeometry, sunMaterial);
        sun.position.set(-moon_x, -moon_y, -moon_z);

        starHolder.add(sun);


        // beadandó ambiens fény
        ambientLight = new THREE.AmbientLight(0xffffff, 1); // 0.4 ízlésesnek tűnik
        ambientLight.position.set(moon_x, moon_y, moon_z);
        scene.add(ambientLight);

        // beadandó irányfény
        moonDirLight = new THREE.DirectionalLight(0xffffff, 1);
        moonDirLight.position.set(moon_x, moon_y, moon_z);
        moonDirLight.castShadow = true;
        //scene.add(new THREE.DirectionalLightHelper( moonDirLight, 1 ));

        moonDirLight.shadow.mapSize.width = 512;
        moonDirLight.shadow.mapSize.height = 512;

        // ezeket nem én találtam ki, de nélkülük úgy tűnik nem működik az árnyék
        // (talán túl messze van / túl nagy a terület)

        moonDirLight.shadow.camera.near = 100;
        moonDirLight.shadow.camera.far = 1000;
        moonDirLight.shadow.camera.left = -500;
        moonDirLight.shadow.camera.right = 500;
        moonDirLight.shadow.camera.top = 500;
        moonDirLight.shadow.camera.bottom = -500;

        sunDirLight = new THREE.DirectionalLight(0xffffff, 3);
        sunDirLight.position.set(-moon_x, -moon_y, -moon_z);
        sunDirLight.castShadow = true;
        //scene.add(new THREE.DirectionalLightHelper( sunDirLight, 1 ));

        sunDirLight.shadow.mapSize.width = 512;
        sunDirLight.shadow.mapSize.height = 512;

        // ezeket nem én találtam ki, de nélkülük úgy tűnik nem működik az árnyék
        // (talán túl messze van / túl nagy a terület)

        sunDirLight.shadow.camera.near = 300;
        sunDirLight.shadow.camera.far = 1000;
        sunDirLight.shadow.camera.left = -500;
        sunDirLight.shadow.camera.right = 500;
        sunDirLight.shadow.camera.top = 500;
        sunDirLight.shadow.camera.bottom = -500;

        starHolder.add(sunDirLight)

        // csillagozás

        for(let i = 0; i < 300; i++){
            let x = 2*sky_rad*Math.random()-sky_rad;
            let z = 2*sky_rad*Math.random()-sky_rad;
            let y = skyY(x,z, sky_rad);

            makeStar(x,y,z,scene)
        }

        // bogarak
        for(let i = 0; i < 100; i++){
            let x = 2*sky_rad*Math.random()-sky_rad;
            let z = 2*sky_rad*Math.random()-sky_rad;
            let y = 0.5 + 5*Math.random()

            makeFireFly(x,y,z,scene)
        }

        //////////////////// Holderek hozzáadaása ////////////////////

        scene.add(starHolder);
        scene.add(fireFlyHolder);
        scene.add(smurfHolder);
        scene.add(lombHolder);


        // Az ablak későbbi átméretezése esetén visszahívható függvény megadása
        window.addEventListener( 'resize', handleWindowResize, wire_frame );

        // Kamera vezérlés
        controls = new TrackballControls( camera, renderer.domElement );
        controls.rotateSpeed = 5.0;
        controls.panSpeed = 1.0;
    }

    function clipsIntoHouse(x,z, h_x, h_z){
        // ne ütközzenek az objektumok a házzal
        return Math.abs(x - h_x) < 10 || Math.abs(z - h_z) < 10;
    }

    function makeFireFly(x, y, z, scene){
        let fireflyGroup = new THREE.Group();

        let geometry = new THREE.SphereGeometry(0.3, 8, 8);
        let material = new THREE.MeshStandardMaterial({color: 0x47ff05, emissive:0x47ff05})
        let ff = new THREE.Mesh(geometry, material);

        ff.position.set(0, 0, 0);

        // Beadandó pontfény
        let light = new THREE.PointLight(0x47ff05, 200, 100);
        light.position.set(0, 0, 0);

        fireflyGroup.add(ff);
        fireflyGroup.add(light);

        fireflyGroup.position.set(x, y, z);

        fireflyGroup.phase = 20 + 20*Math.random();
        fireflyGroup.dir = Math.random() > 0.5 ? 1 : -1;


        fireFlyLights.push(light);
        fireFlyHolder.add(fireflyGroup);
    }

    function makeStar(x, y, z, scene){
        let geometry = new THREE.SphereGeometry(0.5,8,8);
        let material = new THREE.MeshBasicMaterial({color: 0xffffff})
        let star = new THREE.Mesh(geometry, material);
        star.position.set(x,y,z);
        starHolder.add(star);
        //stars.push(star);
        //scene.add(star)
    }

    function makeCustomTree(x, y, z, scene, name) {

        let treeClone = loadedModels[name].clone();
        if (!treeClone) return;

        treeClone.position.set(x, y, z);
        treeClone.rotation.y = 2*Math.PI *Math.random();
        let random_scale = Math.random();
        treeClone.scale.set(1+random_scale,1+random_scale,1+random_scale);


        scene.add(treeClone);
    }
    function makeCustomRock(x, y, z, scene, name) {

        let treeClone = loadedModels[name].clone();
        if (!treeClone) return;

        treeClone.position.set(x, y, z);
        treeClone.rotation.y = 2*Math.PI *Math.random();
        treeClone.scale.set(3+2*Math.random(),3+2*Math.random(),3+2*Math.random());

        scene.add(treeClone);
    }
    function makeCustomTrunk(x, y, z, scene, name) {

        let treeClone = loadedModels[name].clone();
        if (!treeClone) return;

        treeClone.position.set(x, y, z);
        treeClone.rotation.y = 2*Math.PI *Math.random();
        let random_scale = 0.1*Math.random();
        treeClone.scale.set(1+random_scale,1+random_scale,1+random_scale);




        scene.add(treeClone);
    }

    function makeOak(x, y, z, scene, foilageTexture){
        let height_factor = 8+ Math.floor(8*Math.random());
        let radius = 10;
        let lomb_cnt = 5;

        let points = [];
        for (let i = 0; i < height_factor; i++)
            points.push(new THREE.Vector3((0.5*Math.random() - 0.25), i*2, 0))

        let path = new THREE.CatmullRomCurve3(points);
        let geometry = new THREE.TubeGeometry(path, 20, 2, 8, false);
        let material = new THREE.MeshLambertMaterial( { color: 0x873e23, wireframe: wire_frame } );
        let trunk = new THREE.Mesh(geometry, material);

        trunk.position.set(0, 0, 0);
        trunk.rotation.set(0, Math.PI, 0);
        trunk.castShadow = true;
        trunk.receiveShadow = true;

        let trunkGroup = new THREE.Group();
        trunkGroup.add(trunk);
        trunkGroup.position.set(x, y, z);
        scene.add(trunkGroup);

        let colors = [0x138c2f, 0x21ba45, 0x0d561e]
        let lombGroup = new THREE.Group();

        for (let i = 0; i < lomb_cnt; i++) {
            let lombMaterial = new THREE.MeshLambertMaterial({ color: random_choice(colors), wireframe: wire_frame });
            lombMaterial.map = foilageTexture;

            let lomb = new THREE.Mesh(
                new THREE.SphereGeometry(radius, 10, 10),
                lombMaterial);

            lomb.position.set(10*Math.random()-5, height_factor*2 +10*Math.random()-5, 10*Math.random()-5);

            let random_scale = 0.5 + Math.random()/2
            lomb.scale.set(random_scale,random_scale,random_scale);
            lomb.castShadow = true;
            lomb.receiveShadow = true;

            lombGroup.add(lomb);
        }

        lombGroup.position.set(x, y, z);

        lombHolder.add(lombGroup);
    }


    function makeSmurf(x, y, z, scene, faceTexture){
        let smurf = new THREE.Group();

        //Sapka
        let geometryHat = new THREE.ConeGeometry( 1, 2, 16 );
        let materialHat = new THREE.MeshPhongMaterial( {
            color: 0xf33838,
            shininess: 50,
            specular: 0xFFFFFF,
            wireframe: wire_frame} );
        let hat = new THREE.Mesh(geometryHat, materialHat );
        hat.position.set(0,3.3,0);
        hat.rotation.set(0, Math.PI, 0); // beadandó követelmény
        smurf.add(hat);

        //Fej
        let geometryHead = new THREE.SphereGeometry(1)
        let materialHead = new THREE.MeshLambertMaterial( {color: 0xf7c05c, wireframe: wire_frame} );
        let head = new THREE.Mesh(geometryHead, materialHead);
        materialHead.map = faceTexture;
        head.position.set(0,1.7,0);
        smurf.add(head);

        //Test
        let colors = [0xD9004C, 0xD92200, 0xD98D00, 0x00D98D, 0x004CD9];
        let geometryBody = new THREE.CylinderGeometry(0.8, 1, 2, 16);
        let materialBody = new THREE.MeshLambertMaterial( {color: random_choice(colors), wireframe: wire_frame } );
        let body = new THREE.Mesh(geometryBody, materialBody);
        body.position.set(0,0,0);
        hat.rotation.set(0, Math.PI, 0); // beadandó követelmény
        smurf.add(body);

        let scale = 2;

        smurf.scale.set(scale, scale, scale);
        smurf.position.set(x,y+scale,z);
        smurf.rotation.set(0,2*Math.PI*Math.random(),0)

        hat.castShadow = true;
        head.castShadow = true;
        body.castShadow = true;

        smurf.dir = Math.random() > 0.5 ? 1 : -1;
        smurf.phase =  30*Math.random();

        smurfArray.push(smurf);
        scene.add(smurf);
    }

    function makeHouse(x, y, z, scene, doorTexture, windowTexture, roofTexture){
        let house = new THREE.Group();

        // Test
        let geometryRect = new THREE.BoxGeometry(5, 3, 5);
        let materialRect = new THREE.MeshLambertMaterial({color:0x9C530B, wireframe: wire_frame});
        let rect = new THREE.Mesh(geometryRect, materialRect);
        rect.position.set(0, 0, 0);
        rect.rotation.set(0, 2*Math.PI, 0);  // beadandó követelmény
        house.add(rect);

        // Tető
        let geometryRoof = new THREE.ConeGeometry(3, 4, 4)
        //let geometryRoof = new THREE.CylinderGeometry(3.5, 3.5, 7, 3);
        let materialRoof = new THREE.MeshPhongMaterial({
            color:0xC4230E,
            shininess: 10,
            specular: 0x000000,
            wireframe: wire_frame});
        materialRoof.map = roofTexture;
        let roof = new THREE.Mesh(geometryRoof, materialRoof);

        // Fáradságos forgatás
        //roof.rotation.set(THREE.MathUtils.degToRad(90),THREE.MathUtils.degToRad(180),THREE.MathUtils.degToRad(180));
        //let scale = 0.75;
        roof.rotation.set(0, THREE.MathUtils.degToRad(45), 0)
        roof.position.set(0, 3.5, 0);
        roof.scale.set(1.5, 1, 1.5);

        house.add(roof);

        // ablak
        let windowPos = [
            new THREE.Vector3(-2.51, 0.5, -1.5),
            new THREE.Vector3(2.51, 0.5, -1.5),
            new THREE.Vector3(-2.51, 0.5, 1.5),
            new THREE.Vector3(2.51, 0.5, 1.5)]

        let windowMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFAA, side: THREE.DoubleSide, transparent: true, opacity: 0.8 });
        windowMaterial.map = windowTexture;
        let windowGeometry = new THREE.CircleGeometry(0.5, 30);

        for(let i = 0; i < windowPos.length; i++){
            let window = new THREE.Mesh(windowGeometry, windowMaterial);
            window.position.copy(windowPos[i]);
            window.rotation.set(0,THREE.MathUtils.degToRad(90),0)
            house.add(window);

            let sLight = new THREE.SpotLight( 0xFFFFAA, 12, 100, 0.8);
            sLight.position.copy(windowPos[i]);
            sLight.decay = 0.1;
            sLight.penumbra = 0.4;
            sLight.castShadow = true;

            windowLights.push(sLight);

            // hogy scalelődjön ez is a house-szal
            let target = new THREE.Object3D();
            target.position.set(windowPos[i].x * 2, windowPos[i].y, windowPos[i].z);
            sLight.target = target;

            house.add(sLight);
            house.add(target);

            //if (i === 0)
            //    house.add(new THREE.SpotLightHelper( sLight ))
        }

        // ajtó
        let doorMaterial = new THREE.MeshLambertMaterial({ color: 0xFFAA33, side: THREE.DoubleSide });
        doorMaterial.map = doorTexture;
        let doorGeometry = new THREE.PlaneGeometry(1.2, 2);
        let door = new THREE.Mesh(doorGeometry, doorMaterial);
        door.position.set(0, -0.5, -2.51);
        house.add(door);

        let size = 6;
        house.position.set(x,y,z);
        house.scale.set(size, size, size);  // nagyítás
        rect.castShadow = true;
        roof.castShadow = true;
        scene.add(house);
    }

    function random_choice(list){
        return list[Math.floor(list.length * Math.random())];
    }

    function skyY(x,z,sky_radius){
        // z koordináta x,y alapján ami az égen lesz
        // x^2 + y^2 + z^2 == sky_radius^2
        // y = sqrt(sky_radius^2 - x^2 - z^2)

        return Math.sqrt(sky_radius*sky_radius - x*x - z*z)
    }

    ////////////////// ObjectTesterSkeleton.html-ből származó részek //////////////////
    function handleWindowResize() {
        // Az ablak átméretezése esetén a kamera vetítési paraméterek újraszámolása
        HEIGHT = window.innerHeight;
        WIDTH = window.innerWidth;
        console.log( 'WIDTH=' + WIDTH + '; HEIGHT=' + HEIGHT );
        renderer.setSize( WIDTH, HEIGHT );
        aspectRatio = WIDTH / HEIGHT;
        camera.aspect = aspectRatio;
        camera.updateProjectionMatrix();

        render();
    }
    function animate() {
        ff_time += 0.0005;
        smurf_time += 0.0005;

        requestAnimationFrame( animate );

        controls.update();

        starHolder.rotation.x = day ? Math.PI : 0;


        fireFlyHolder.children.forEach(fireFly => {
            fireFly.position.x += fireFly.dir * Math.sin(ff_time*fireFly.phase)*0.3;
            fireFly.position.z += fireFly.dir * Math.cos(ff_time*fireFly.phase)*0.3;

            fireFly.position.y += Math.sin(ff_time*fireFly.phase)*0.2;
        })

        if(day){
            smurfArray.forEach(smurf => {
                smurf.position.x += smurf.dir * Math.sin(smurf_time*smurf.phase)*0.3;
                smurf.position.z += smurf.dir * Math.cos(smurf_time*smurf.phase)*0.3;
            })
        }

/*
        if(!smurfFlipping){
            smurfFlipping = true;
            smurfToFlip = random_choice(smurfArray);
            smurfHolder.add(smurfToFlip);
        }
        else{
            smurfToFlip.rotation.z += 0.1;
            smurfToFlip.position.y += Math.sin(smurfToFlip.rotation.z)
            if(smurfToFlip.rotation.z > 2 * Math.PI){
                smurfFlipping = false;
            }
        }
*/
        render();
    }

    function render() {
        // 3D -> 2D vetített kép kiszámítása.
        // scene 3D színtér képe a camera kamera szemszögéből.
        renderer.render( scene, camera );
    }

    function toggleWindowLights(){
        for(let i = 0; windowLights.length > i; ++i){
            windowLights[i].intensity = windowLightsOn ? 13 : 0;
        }
    }

    function toggleFireFlyLights(){
        for(let i = 0; fireFlyLights.length > i; ++i){
            fireFlyLights[i].intensity = fireFlyLightsOn ? 200 : 0;
        }
    }

    function toggleDayNightLight(){
        if(day){

            sunDirLight.intensity = 3;
            moonDirLight.intensity = 0;

            ambientLight.color.setHex(0xFFFFFF);
            ambientLight.intensity = 0.8;

            scene.background = new THREE.Color(0x87CEEB);
        }
        else{
            sunDirLight.intensity = 0;
            moonDirLight.intensity = 2;

            ambientLight.color.setHex(0x8303ba);
            ambientLight.intensity = 0.4;

            scene.background = new THREE.Color(0x000000);
        }
    }

</script>
</body>
</html>
